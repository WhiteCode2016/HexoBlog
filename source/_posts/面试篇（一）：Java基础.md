---
title: Java面试题总结
date: 2019-05-28 11:15:23
categories: 面试
---

#### Java的特征

封装、继承、多态、抽象

#### 重写与重载的区别

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或参数顺序不同），则视为重载，重载对返回类型没有特殊的要求，不能根据返回类型进行区分；
重写发生在子类与父类之间，要求子类被重写的方法与父类被重写的方法有相同的参数列表，有兼容的返回类型，则视为重写。

#### 抽象类与接口的区别

默认的实现方法：抽象类可以有默认的实现方法；接口完全是抽象的，根本不存在实现的方法。
实现：子类需要通过extends继承抽象类，如果子类不是抽象类的话，需要提供抽象类中所有声明的方法的实现；子类需要通过implement来实现接口，它需要提供接口中所有声明的方法的实现。
构造器：抽象类可以有构造器；接口不能有。
与正常Java类的区别：除了不能实例化抽象类之外，与普通Java类型没有任何区别；接口是完全不同的类型。
访问修饰符：抽象方法可以有public、protected和default；接口方法默认是public，且不能使用其他修饰符。
main方法：抽象方法可以有main方法并且可以运行；接口没有main方法。
多继承：抽象类可以继承一个类和实现多个接口；接口只能继承一个或多个其他接口。
添加新方法：往抽象类中添加新方法，你可以给你提供默认的实现，你可以不需要改变你现在的代码；往接口中添加新方法，你必须改变实现该接口的类。

#### `hasCode()`与`equal()`的作用、区别、联系

`hashCode()`与`equal()`方法的作用其实是一样的，都是用来比较两个对象是否相等。
重写`equal()`方法比较的比较全面和复杂，效率较低，而利用`hashCode()`进行对比，只要生成一个hash值进行比较，效率高。
`hashCode()`并不是完全可靠的，有时候不同的对象他们生成的hash值也会一样，所以`hashCode()`只能说大部分时候可靠，并不是绝对可靠。
总结：`equal()`相等的两个对象的`hashCode()`肯定相等，也就是`equal()`对比绝对可靠；`hashCode()`相等的两个对象的`equal()`不一定相等，也就是`hashCode()`不是绝对可靠。

#### `equal()`与`==`的区别

对于`==`,如果作用于基本数据类型的变量，则直接比较其存储的值是否相等，如果作用于引用类型，则比较的是所指向的对象的地址；
对于`equal()`方法，如果没有对`equal()`方法进行重写，则比较的是引用类型的变量所指向的对象的地址,注意：`equal()`方法不能作用于基本数据类型的变量。

#### `String`、`StringBuffer`和`StringBuilder`的区别

`String`类中使用字符数组保存字符串并用final修饰，`StringBuffer`和`StringBuilder`都继承自`AbstractStringBuilder`类，`AbstractStringBuilder`中也使用字符数组保存字符串。
`String`对象是不可变的，也就是可以理解为常量，显然线程安全；
`StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的；
`StringBuilder`并没有对方法进行加同步锁，所以是非线程安全的。

#### `List`、`Set`、`Map`的区别

`List`、`Set`都是继承自`Collection`接口；
`List`特征：元素有放入顺序，可重复；
`Set`特征：元素无放入顺序，不可重复，重复元素会覆盖；
`Map`特征：元素无序，key值不可重复（value值可重复）；

#### `ArrayList`与`LinkedList`的区别

`ArrayLis`t是基于动态数组的数据结构实现的，因为地址连续，插入和删除操作效率比较低，适合查询；`LinkedList`是基于链表的数据结构实现的，因为地址是任意的，开辟空间的时候不需要一个连续的地址，对于查询操作效率比较低，适合插入和删除操作。

#### `ArrayList`与`Vector`的区别

- `ArrayList`和`Vector`都实现了`List`接口，都是有序集合，并且存放的元素是允许重复的，都是采用了线性连续空间存储元素；
- `Vector`是线程安全的，而`ArrayList`是线程不安全的；
- `ArrayList`和`Vector`都有一个初始的容量大小（10），当存储进它们里面的元素超过了容量，就需要增加它们的存储容量。`ArrayList`每次增长原来的0.5倍，而`Vector`增长原来的一倍。`ArrayList`和`Vector`都可以设置初始空间的大小，`Vector`还可以设置增长的空间大小，而`ArrayList`没有提供设置增长空间的方法。

#### `HashMap`与`HashTable`的区别
- `HashMap`和`HashTable`都实现了Map接口，都是key-value的数据结构；
- `HashTable`是线程安全的，而`HashMap`是线程不安全的；
- `HashMap`允许将null值作为key或value，而`HashTable`不允许(会抛`NullPointerException`)。

#### `HashMap`与`TreeMap`的区别
- `HashMap`通过`hashCode`对其内容进行快速查找，而`TreeMap`中所有的元素都保持着某种固定的顺序，如果需要得到一个有序的结果就使用`TreeMap`。
- `HashMap`基于哈希表实现，可以调优初始化容量和负载因子，适用于插入、删除和定位元素；
- `TreeMap`基于红黑树实现，没有优化选项，该树总处于平衡状态，适用于按自然顺序或自定义顺序遍历键。